

# 1. 架构和历史
- 支持数据仓库，内同缩影和部署软件，高可用的冗余系统，在线事务处理系统（OLTP）
- 存储引擎架构，将查询处理及其他系统任务，和数据的存储/提取相分离
## mysql逻辑框架
- 分层
  - 网络客户端/服务器的工具：连接处理，授权认证，安全
  - 查询解析，分析，优化，缓存以及所有的内置函数
  - 存储引擎: 数据的存储和提取
- 连接管理与安全性
  - 客户端连接，拥有一个线程。
  - 安全认证，使用安全套接字（SSL）
- 优化与执行
  - 解析查询，创建内部数据结构，进行优化

## 并发控制
- 服务器层，存储引擎层
- 读写锁
  - 共享锁/读锁：互相不阻塞
  - 排他锁/写锁：一个写锁回阻塞其他的写锁和读锁
- 锁粒度
  - 锁消耗资源，有相应的开销
  - 锁策略，锁粒度
  - 表锁：开销最小
  - 行级锁：最大程度的支持并发处理，锁开销大

## 事务
- 一组原子性的SQL查询，独立的工作单元。要么全部执行，要么全部执行失败
- ACID ：原子性，一致性，隔离性，持久性
- 隔离级别
  - read uncommitted 未提交读：可以读取到未提交的数据，脏读
  - read commited 提交读：提交后，才可以读：不可重复读，可能回得到不一样的结果
  - repeatable read 可重复读：同一个事务重，多次读取的结果是一样的：
  - serializable：可串行化：解决了幻读
- 死锁
  - 多个事务，以不同的顺序锁定资源，产生恶性循环，产生死锁
  -  死锁检测，死锁超时机制
-  事务日志
- mysql的事务
  - 自动提交
  - 在事务重混合使用存储引擎
  - 隐式和显示锁定

## 多版本并发控制 （MVVC）
- 行级锁的变种
- 通过每行记录后面保存亮哥隐藏的列来实现，一个保存了行的创建时间，一个保存行的过期时间：系统版本号

## 存储引擎
- show table status like ''
- InnoDB引擎
  - 使用MVVC
  - 聚簇索引
- MyISAM引擎
  - 不支持事务和行级锁
  - 加锁，并发，修复，索引特性
  - 压缩表
- 其他存储引擎
  - archive引擎
  - blackhole引擎
  - csv引擎
  - federated引擎
  - memory引擎
  - merge引擎
  - ndb集群引擎
- 第三方
  - OLTP引擎
  - 面向列的存储引擎
  - 社区存储引擎
- 引擎选择
  - 事务支持
  - 备份
  - 崩溃恢复
  - 稀有的特性
- 转换表引擎
## mysql时间线
- 5.1 之后用了InnoDB plugin

## mysql的开发模式

# 2. MYSQL基准测试

- 为什么要基准测试
- 基准测试的策略
  - 集成式
  - 单组件式
  - 指标
    - 吞吐量
    - 响应时间或者延迟
    - 并发性
    - 可扩展性
- 基准测试方法
- 基准测试工具
- 基准测试案例


# 3. 服务器性能剖析

## 性能优化简介
- 定义：性能即响应时间
  - 服务器每秒可以执行更多的查询，即每条查询执行的时间更短了
  - 执行时间：测量定位不同的子任务花费的使劲啊，优化去掉一些，降低频率或提升效率
  - 等待时间：其他系统间接影响导致，争用磁盘或者CPU资源
  - 通过性能剖析优化profile

## 对应用程序进行性能剖析
- 使用工具
- 对整个数据库服务器进行分析
- 对部分进行分析

## 剖析mysql查询
- 剖析服务器负载
  - 定位和优化‘坏’查询
  - 捕获mysql的查询到日志文件中——慢查询日志
  - 通用日志
  - 抓取TCP网络包
- 分析查询日志
- 分析单条查询
  - show profile：默认是禁用的，测量时间和其他一些查询执行状态变更的相关数据
  - show status:计数器
- 使用性能查询你

## 诊断间歇性问题
- 避免用试错的方式
- 是单条查询问题，还是服务器的问题

## 其他剖析工具
- 使用user_statistics表

# 第四章 Schema与数据类型优化

## 选择优化的数据类型
- 更小的通常更好：更少的磁盘，内存和CPU缓存
- 简单就好：整型比字符操作代价更低
- 尽量避免null

- 整数类型
- 实数类型：带有小数部分
  - decimal
  - float,double
- 字符串类型
  - varchar,char
  - blob和text类型
  - enum
- 日期和时间类型
  -  最小时间粒度为秒
  -  datatime:8个字节，与时区无关
  -  timestam: 4个字节，依赖时区，FROM-UNIXTIME()和UNIX_TIMESTAMP()
  -  可以使用BIGINT类型村塾微妙级别的时间戳，用double存储秒之后的小数部分
-  位数据类型
  - bit
- 选择标识符
- 特殊类型数据

## 范式和反范式
- 三大范式
  - 1.有主键，字段原子性，不可分割
  - 2. 字段完全依赖于主键，多对多
  - 3. 没有传递依赖
- 范式
  - 优点：update快，存储小，更好的放在内存，执行操作快
  - 缺点：需要关联，
- 反范式
  - 优点： 避免了随机I/O，当数据比内存大的时候。索引更有效
  - 缺点：数据大
- 实际上混合使用。

## 缓存表和汇总表
- 缓存表：存储获取数据比较慢，逻辑上冗余
- 汇总表：用group by 聚合数据的表

- 物化视图
  - 预先计算并且存储再磁盘上的表，可以通过各种各样的策略刷新和更新
  - mysql并不支持原生的物化视图
- 计数器表
  - 保存计数器，应对高并发，运用随机的槽和sum实现
  - 可以周期执行一个任务，合并所有结果到0号槽

## 加快alter table操作的速度
- 对大表来说时间太久
- 先在一台不提供服务的机器上执行alter table ，在切换
- 影子拷贝：建新表，然后重命名和删表
- 通过alter column 来操作.frm 文件，来加速

- 只修改.frm文件
- 快速创建MyISAM索引
  - 先禁用索引，载入数据，然乎重新启用索引
  - 对唯一索引无效


# 第五章 创建高性能的索引
存储引擎快速找到记录的一种数据结构

## 索引基础
- 索引的类型
- B-Tree 索引
  - InnoDB使用的是B+tree
  - 有叶子节点
  - 索引列的顺序很重要，不按照顺序，或者范围查询，将无法使用索引优化查找
- 哈希索引
  - memory中使用的是哈希索引
  - 生成hash code，存储的是键值对
  - 只支持等值查询，不支持范围查询
  - 自定义哈希索引
    - 如url_crc
- 空间数据索引
- 全文索引

## 索引的优点
- 减少扫描的数据量
- 帮助服务器避免排序和临时表
- 可以将随机I/O变为顺序I/O

## 高性能的索引策略

- 独立的列：索引列不能是表达式的一部分
- 前缀索引和索引选择性：索引的选择性越高，则查询效率越高，唯一索引的选择性是1
  - 对于bolb text 必须使用前缀索引 
  - 计算完整列的选择性，是前缀的选择性接近
- 多列索引
  - 索引合并策略
- 选择合适的索引列顺序
  - 条件的选择性
- 聚簇索引
  - 在同一个结构中保存了B-tree索引和数据行
  - 可以把相关数据保存在一起，数据访问更快
  - 提高了I/O密集型应用的性能
  - 更新的代价很高
- 数据分布对比
- 覆盖索引
  - 一个索引包含所有需要查询的字段的值
- 使用索引扫描来做排序
- 压缩索引
- 冗余和重复索引
- 未使用的索引
- 索引和锁
  - 索引能较少访问的行数，减少锁的数量

## 索引案例学习
- 支持多种过滤条件
- 避免多个范围条件
- 优化排序


## 维护索引和表
- 找到并修复损坏的表
  - check table 检查
  - repair table 修复
- 更新索引统计信息
  - 查询优化器，通过两个api查询
- 减少索引和数据的碎片
  - optimize table 或者导出在导入的方式来重新整理数据
  - 先删除，在重新创建索引的方式


# 第六章 查询性能优化

- 查询为什么慢
  - 优化的目的，减少和消除，重复性的操作花费的时间
- 慢查询的基础：优化数据访问
  - 访问的数据量是否太多
    - 查询不需要的记录
    - 多表关联时返回全部列
    - 总是取出全部列
    - 重复查询相同的数据
  - 服务器层是否在分析大量超过需要的数据行
  - 是否在扫描额外的记录
    - 响应时间
    - 扫描的行数和返回的行数
    - 扫描的行数和访问类型
- 重构查询的方式
  - 一个复杂查询还是多个简单查询
  - 切分查询
  - 分解关联查询
    - 让缓存的效率更高
    - 减少锁的竞争
    - 应用关联，更容易对数据进行拆分
    - 效率提升
    - 减少冗余的查询
- 查询执行的基础
  - 流程
    - 客户端发送查询给服务器
    - 服务器先检查查询缓存
    - 进行SQL解析，预处理，优化生成执行计划
    - mysql根据执行计划，调用存储引擎的api执行查询
    - 结果返回给客户端
  - 客户端/服务器通信协议
    - 半双工的
      - 查询语句的max-allowed_packet
      - 查询加上limit
    - 查询状态
      - show full processlist
      - sleep query locked analyzing and statisiics copying to tmp table sorting result sending data
    - 查询缓存
    - 查询优化处理
      - 语法解析器和预处理
      - 查询优化器
        - 重新定义关联表的顺序
        - 将外连接转化成内连接
        - 等价变换规则
        - 优化count(),min(),max()
        - 预估并转化位常数表达式
        - 覆盖索引扫描
        - 子查询优化
        - 提前终止查询
  - 查询执行引擎
  - 返回结果给客户端
- 查询优化器的局限性
  - 关联子查询-很糟糕
    - 使用group_concat)_更好
    - 左外连接
  - union的限制
  - 索引合并优化
  - 等值传递
- 查询优化器的提示（hint）
- 优化特定类型的查询
  - count()
    - 统计列值：要求列值非空
    - 统计结果集的行数 *
    - 简单的优化
    - 使用近似值
    - 更复杂的优化
  - 关联查询  
  - 子查询
  - group by 和distinct
  - limit 分页
  - sql——calc_found_rows
  - union
  - 静态查询分析
  - 用户自定义变量
- 案例学习
  - 使用mysql 构建一个队列表
  - 计算两个点之间的距离
  - 使用用户自定义函数


# 第七章 mysql高级特性











