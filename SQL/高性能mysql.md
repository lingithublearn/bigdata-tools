

# 1. 架构和历史
- 支持数据仓库， 内部索引和部署软件，高可用的冗余系统，在线事务处理系统（OLTP）
- 存储引擎架构，将查询处理及其他系统任务，和数据的存储/提取相分离
## mysql逻辑框架
- 分层
  - 网络客户端/服务器的工具：连接处理，授权认证，安全
  - 查询解析，分析，优化，缓存以及所有的内置函数
  - 存储引擎: 数据的存储和提取
- 连接管理与安全性
  - 客户端连接，拥有一个线程。
  - 安全认证，使用安全套接字（SSL）
- 优化与执行
  - 解析查询，创建内部数据结构，进行优化

## 并发控制
- 服务器层，存储引擎层
- 读写锁
  - 共享锁/读锁：互相不阻塞
  - 排他锁/写锁：一个写锁回阻塞其他的写锁和读锁
- 锁粒度
  - 锁消耗资源，有相应的开销
  - 锁策略，锁粒度
  - 表锁：开销最小
  - 行级锁：最大程度的支持并发处理，锁开销大

## 事务
- 一组原子性的SQL查询，独立的工作单元。要么全部执行，要么全部执行失败
- ACID ：原子性，一致性，隔离性，持久性
- 隔离级别
  - read uncommitted 未提交读：可以读取到未提交的数据，脏读
  - read commited 提交读：提交后，才可以读：不可重复读，可能回得到不一样的结果
  - repeatable read 可重复读：同一个事务重，多次读取的结果是一样的：
  - serializable：可串行化：解决了幻读
- 死锁
  - 多个事务，以不同的顺序锁定资源，产生恶性循环，产生死锁
  -  死锁检测，死锁超时机制
-  事务日志
- mysql的事务
  - 自动提交
  - 在事务重混合使用存储引擎
  - 隐式和显示锁定

## 多版本并发控制 （MVVC）
- 行级锁的变种
- 通过每行记录后面保存亮哥隐藏的列来实现，一个保存了行的创建时间，一个保存行的过期时间：系统版本号

## 存储引擎
- show table status like ''
- InnoDB引擎
  - 使用MVVC
  - 聚簇索引
- MyISAM引擎
  - 不支持事务和行级锁
  - 加锁，并发，修复，索引特性
  - 压缩表
- 其他存储引擎
  - archive引擎
  - blackhole引擎
  - csv引擎
  - federated引擎
  - memory引擎
  - merge引擎
  - ndb集群引擎
- 第三方
  - OLTP引擎
  - 面向列的存储引擎
  - 社区存储引擎
- 引擎选择
  - 事务支持
  - 备份
  - 崩溃恢复
  - 稀有的特性
- 转换表引擎
## mysql时间线
- 5.1 之后用了InnoDB plugin

## mysql的开发模式

# 2. MYSQL基准测试

- 为什么要基准测试
- 基准测试的策略
  - 集成式
  - 单组件式
  - 指标
    - 吞吐量
    - 响应时间或者延迟
    - 并发性
    - 可扩展性
- 基准测试方法
- 基准测试工具
- 基准测试案例


# 3. 服务器性能剖析

## 性能优化简介
- 定义：性能即响应时间
  - 服务器每秒可以执行更多的查询，即每条查询执行的时间更短了
  - 执行时间：测量定位不同的子任务花费的使劲啊，优化去掉一些，降低频率或提升效率
  - 等待时间：其他系统间接影响导致，争用磁盘或者CPU资源
  - 通过性能剖析优化profile

## 对应用程序进行性能剖析
- 使用工具
- 对整个数据库服务器进行分析
- 对部分进行分析

## 剖析mysql查询
- 剖析服务器负载
  - 定位和优化‘坏’查询
  - 捕获mysql的查询到日志文件中——慢查询日志
  - 通用日志
  - 抓取TCP网络包
- 分析查询日志
- 分析单条查询
  - show profile：默认是禁用的，测量时间和其他一些查询执行状态变更的相关数据
  - show status:计数器
- 使用性能查询你

## 诊断间歇性问题
- 避免用试错的方式
- 是单条查询问题，还是服务器的问题

## 其他剖析工具
- 使用user_statistics表

# 第四章 Schema与数据类型优化

## 选择优化的数据类型
- 更小的通常更好：更少的磁盘，内存和CPU缓存
- 简单就好：整型比字符操作代价更低
- 尽量避免null

- 整数类型
- 实数类型：带有小数部分
  - decimal
  - float,double
- 字符串类型
  - varchar,char
  - blob和text类型
  - enum
- 日期和时间类型
  -  最小时间粒度为秒
  -  datatime:8个字节，与时区无关
  -  timestam: 4个字节，依赖时区，FROM-UNIXTIME()和UNIX_TIMESTAMP()
  -  可以使用BIGINT类型村塾微妙级别的时间戳，用double存储秒之后的小数部分
-  位数据类型
  - bit
- 选择标识符
- 特殊类型数据

## 范式和反范式
- 三大范式
  - 1.有主键，字段原子性，不可分割
  - 2. 字段完全依赖于主键，多对多
  - 3. 没有传递依赖
- 范式
  - 优点：update快，存储小，更好的放在内存，执行操作快
  - 缺点：需要关联，
- 反范式
  - 优点： 避免了随机I/O，当数据比内存大的时候。索引更有效
  - 缺点：数据大
- 实际上混合使用。

## 缓存表和汇总表
- 缓存表：存储获取数据比较慢，逻辑上冗余
- 汇总表：用group by 聚合数据的表

- 物化视图
  - 预先计算并且存储再磁盘上的表，可以通过各种各样的策略刷新和更新
  - mysql并不支持原生的物化视图
- 计数器表
  - 保存计数器，应对高并发，运用随机的槽和sum实现
  - 可以周期执行一个任务，合并所有结果到0号槽

## 加快alter table操作的速度
- 对大表来说时间太久
- 先在一台不提供服务的机器上执行alter table ，在切换
- 影子拷贝：建新表，然后重命名和删表
- 通过alter column 来操作.frm 文件，来加速

- 只修改.frm文件
- 快速创建MyISAM索引
  - 先禁用索引，载入数据，然乎重新启用索引
  - 对唯一索引无效


# 第五章 创建高性能的索引
存储引擎快速找到记录的一种数据结构

## 索引基础
- 索引的类型
- B-Tree 索引
  - InnoDB使用的是B+tree
  - 有叶子节点
  - 索引列的顺序很重要，不按照顺序，或者范围查询，将无法使用索引优化查找
- 哈希索引
  - memory中使用的是哈希索引
  - 生成hash code，存储的是键值对
  - 只支持等值查询，不支持范围查询
  - 自定义哈希索引
    - 如url_crc
- 空间数据索引
- 全文索引

## 索引的优点
- 减少扫描的数据量
- 帮助服务器避免排序和临时表
- 可以将随机I/O变为顺序I/O

## 高性能的索引策略

- 独立的列：索引列不能是表达式的一部分
- 前缀索引和索引选择性：索引的选择性越高，则查询效率越高，唯一索引的选择性是1
  - 对于bolb text 必须使用前缀索引 
  - 计算完整列的选择性，是前缀的选择性接近
- 多列索引
  - 索引合并策略
- 选择合适的索引列顺序
  - 条件的选择性
- 聚簇索引
  - 在同一个结构中保存了B-tree索引和数据行
  - 可以把相关数据保存在一起，数据访问更快
  - 提高了I/O密集型应用的性能
  - 更新的代价很高
- 数据分布对比
- 覆盖索引
  - 一个索引包含所有需要查询的字段的值
- 使用索引扫描来做排序
- 压缩索引
- 冗余和重复索引
- 未使用的索引
- 索引和锁
  - 索引能较少访问的行数，减少锁的数量

## 索引案例学习
- 支持多种过滤条件
- 避免多个范围条件
- 优化排序


## 维护索引和表
- 找到并修复损坏的表
  - check table 检查
  - repair table 修复
- 更新索引统计信息
  - 查询优化器，通过两个api查询
- 减少索引和数据的碎片
  - optimize table 或者导出在导入的方式来重新整理数据
  - 先删除，在重新创建索引的方式


# 第六章 查询性能优化

- 查询为什么慢
  - 优化的目的，减少和消除，重复性的操作花费的时间
- 慢查询的基础：优化数据访问
  - 访问的数据量是否太多
    - 查询不需要的记录
    - 多表关联时返回全部列
    - 总是取出全部列
    - 重复查询相同的数据
  - 服务器层是否在分析大量超过需要的数据行
  - 是否在扫描额外的记录
    - 响应时间
    - 扫描的行数和返回的行数
    - 扫描的行数和访问类型
- 重构查询的方式
  - 一个复杂查询还是多个简单查询
  - 切分查询
  - 分解关联查询
    - 让缓存的效率更高
    - 减少锁的竞争
    - 应用关联，更容易对数据进行拆分
    - 效率提升
    - 减少冗余的查询
- 查询执行的基础
  - 流程
    - 客户端发送查询给服务器
    - 服务器先检查查询缓存
    - 进行SQL解析，预处理，优化生成执行计划
    - mysql根据执行计划，调用存储引擎的api执行查询
    - 结果返回给客户端
  - 客户端/服务器通信协议
    - 半双工的
      - 查询语句的max-allowed_packet
      - 查询加上limit
    - 查询状态
      - show full processlist
      - sleep query locked analyzing and statisiics copying to tmp table sorting result sending data
    - 查询缓存
    - 查询优化处理
      - 语法解析器和预处理
      - 查询优化器
        - 重新定义关联表的顺序
        - 将外连接转化成内连接
        - 等价变换规则
        - 优化count(),min(),max()
        - 预估并转化位常数表达式
        - 覆盖索引扫描
        - 子查询优化
        - 提前终止查询
  - 查询执行引擎
  - 返回结果给客户端
- 查询优化器的局限性
  - 关联子查询-很糟糕
    - 使用group_concat)_更好
    - 左外连接
  - union的限制
  - 索引合并优化
  - 等值传递
- 查询优化器的提示（hint）
- 优化特定类型的查询
  - count()
    - 统计列值：要求列值非空
    - 统计结果集的行数 *
    - 简单的优化
    - 使用近似值
    - 更复杂的优化
  - 关联查询  
  - 子查询
  - group by 和distinct
  - limit 分页
  - sql——calc_found_rows
  - union
  - 静态查询分析
  - 用户自定义变量
- 案例学习
  - 使用mysql 构建一个队列表
  - 计算两个点之间的距离
  - 使用用户自定义函数


# 第七章 mysql高级特性

## 分区表
- 目的：将数据按照一个较粗的粒度分在不同的表中
- 实现方式：对底层表的封装，索引按照分区的子表定义的，没有全局索引
- 原理：对存储引擎，底层表和普通表一样
  - RUD操作时，会先打开并锁住所有底层表，但并不是锁住全表
- 分区表的类型：时间，键值，数学模函数，自增的主键列id
- 为什么用：代价小的定位数据的区域
  - 全量扫米哦啊数据，不要索引
  - 索引数据，并分离热点
- 问题
  - null值会让分区过滤失效：直接用列本身，而不是基于列的函数分区。或者建立无用分区
  - 分区列和索引列不匹配：
  - 选择分区的成本可能很高
  - 打开并锁住所有底层表成本高
  - 维护分区的成本高
- 查询优化：分区键，不用表达式
- 合并表 merge table：union 子表

## 视图

- 视图是一个虚拟表，不存放数据
- 合并算法：查询SQL和视图SQL合并
- 临时表算法：查询SQL，查询视图SQL 生成的临时表。explain:derived
- 可更新视图，聚合函数等就不能更新
- 对性能的影响：不一定提升，需要测试
- 视图的限制
- 暂不支持物化视图（定期刷写）

## 外键约束
- 确保两个相关表始终有一致的数据
- 会有很大的额外消耗

## 在mysql 内部存储代码
- 简介
  - 触发器，存储过程，函数的形式存储代码
  - 事件：定时任务
  - 存储程序：存储过程，存储函数
  - 优点：离数据近，节省带宽和网络延迟，代码重用，简化维护和版本更新
  - 缺点：缺乏调试工具，效率低些。对服务器增加压力
- 存储过程和函数
  - 一般希望存储程序越小，越简单越好
- 触发器
  - 每个表的每一个事件，最多定义一个触发器
  - 基于行的触发
  - 隐藏了很多工作，问题难排查，可能死锁
- 事件
  - 定时执行一段代码，用一个简单的call调用
- 在存储程序中保留注释

## 游标
- 只读的，单向的游标，只能在存储过程或者更底层的api中用


## 绑定变量
- 简介
  - 发送一个sql语句的原型，用？代替实际值
  - 后续直接用值替换
- 绑定变量的优化
  - 执行计划只用优化一次
  - 只需解析一次SQL语句
- SQL接口的绑定变量
  - 存储过程中使用，动态的SQL语句
- 绑定变量的限制


## 用户自定义函数
- UDF
- 事先编译好，并动态链接到服务器上
- 可能让服务器崩溃

## 插件
- 存储过程插件
- 后台插件
- information_schema插件
- 全文解析插件
- 审计插件
- 认证插件


## 字符集和校对
- 简介
  - 字符集是一种从二进制编码到字符符号的映射
- 如何使用
  - 创建对象时的默认值
  - 服务器和客户端通信时的设置
  - mysql比较两个字符串的大小
- 选择字符集和校对规则
- 字符集和校对规则如何影响查询

## 全文索引
- 简介
  - 相似度的查询
  - 类似网站的搜索引擎
- 自然语言的全文索引
  - 出现次数越少，相关度越高
- 布尔全文索引
  - 可以自定义某个被搜索词语的相关性
  - 通过停用次列表过滤掉噪声次
- mysql5.1的变化
- 全文索引的限制和替代方案
  -  需要索引都在内存中
-  全文索引的配置和优化

## 分布式（XA） 事务
- 简介
  - 事务协调器：事务的参与制都完成了准备工作
- 内部XA事务
  - 插件式的架构，需要跨存储引擎的事务的外部协调者
  - 性能下降，破坏了批量提交
- 外部XA事务
  - XA事务是一种再多个服务器之间同步数据的方法
  
 ## 查询缓存
 - 简介
  - 缓存完整的select查询结果
  - 是一个影响服务器扩展性的因素
- 如何判断缓存命中
  - 缓存存放在一个引用表中
  - 任何字符上的不同，都会导致缓存不命中
  - 不确定的数据不会被缓存
- 查询缓存如何使用内存
  - 基本的管理维护数据结构
  - 申请内存块，放入数据，释放空闲的内存空间
- 发挥作用
  - 全局性能指标
  - 消耗大量资源的查询适合
  - 看命中率
  - 看查询时间消耗是否改变
- 配置和维护查询缓存
  - 减少碎片
  - 提高查询缓存的使用率
- innodb 和查询缓存
  - 事务中可以控制是否使用缓存
  - 简化，所有有加锁操作的事务，不适用查询缓存
- 通用查询缓存优化
- 替代方案








